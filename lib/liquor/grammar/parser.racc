class Liquor::Parser
  token comma dot endtag ident integer kwarg lblock lbracket linterp
        lparen op_div op_eq op_gt op_geq op_lt op_leq op_minus op_mod
        op_mul op_neq op_not op_plus pipe plaintext rblock rbracket
        rinterp rparen string tag

  prechigh
    nonassoc op_uminus op_neg
    left op_mul op_div op_mod
    left op_plus op_minus
    left op_eq op_neq op_lt op_leq op_gt op_geq
    left op_and
    left op_or
  preclow

  expect 13

  start block

rule
  block: /* empty */
    | plaintext block
      { result = [ val[0], *val[1] ] }
    | interp block
      { result = [ val[0], *val[1] ] }

  interp:
      linterp expr rinterp
      { result = [ :interp, retag(val), val[1] ] }
    | linterp filter_chain rinterp
      { result = [ :interp, retag(val), val[1] ] }

  primary_expr:
      ident
    | lparen expr rparen
      { result = [ val[1][0], retag(val), *val[1][2..-1] ] }

  expr:
      integer
    | string
    | tuple
    | ident lparen function_args rparen
      { result = [ :call,   retag(val), val[0], val[2] ] }
    | primary_expr lbracket expr rbracket
      { result = [ :index,  retag(val), val[0], val[2] ] }
    | primary_expr dot ident
      { result = [ :access, retag(val), val[0], val[2] ] }
    | op_minus expr =op_uminus
      { result = [ :uminus, retag(val), val[1] ] }
    | op_not expr
      { result = [ :not, retag(val), val[1] ] }
    | expr op_mul expr
      { result = [ :mul, retag(val), val[0], val[2] ] }
    | expr op_div expr
      { result = [ :div, retag(val), val[0], val[2] ] }
    | expr op_mod expr
      { result = [ :mod, retag(val), val[0], val[2] ] }
    | expr op_plus expr
      { result = [ :plus, retag(val), val[0], val[2] ] }
    | expr op_minus expr
      { result = [ :minus, retag(val), val[0], val[2] ] }
    | expr op_eq expr
      { result = [ :eq, retag(val), val[0], val[2] ] }
    | expr op_neq expr
      { result = [ :neq, retag(val), val[0], val[2] ] }
    | expr op_lt expr
      { result = [ :lt, retag(val), val[0], val[2] ] }
    | expr op_leq expr
      { result = [ :leq, retag(val), val[0], val[2] ] }
    | expr op_gt expr
      { result = [ :gt, retag(val), val[0], val[2] ] }
    | expr op_geq expr
      { result = [ :geq, retag(val), val[0], val[2] ] }
    | expr op_and expr
      { result = [ :and, retag(val), val[0], val[2] ] }
    | expr op_or expr
      { result = [ :or, retag(val), val[0], val[2] ] }
    | primary_expr

  tuple:
      lbracket tuple_content rbracket
      { result = [ :tuple, retag(val), val[1].compact ] }

  tuple_content:
      expr comma tuple_content
      { result = [ val[0], *val[2] ] }
    | expr
      { result = [ val[0] ] }
    | /* empty */
      { result = [ ] }

  function_args:
      expr function_kwargs
      { result = [ :args, retag(val), val[0], val[1][2] ] }
    | function_kwargs
      { result = [ :args, retag(val), nil, val[0][2] ] }

  function_kwargs:
      kwarg expr function_kwargs
      { # voodoo. well, it could be worse with (cdadr val) and stuff.
        if val[2][2].include? val[0][2]
          raise SyntaxError.new("duplicate keyword argument `#{val[0][2]}'",
              val[2][2][val[0][2]][1])
        end
        hash = {
          val[0][2] => [ val[1][0], retag([ val[0], val[1] ]), *val[1][2..-1] ]
        }.merge(val[2][2])
        result = [ :kwargs, retag([ val[0], val[2] ]), hash ]
      }
    | /* empty */
      { result = [ :kwargs, nil, {} ] }

  filter_chain:
      filter_call pipe filter_chain_cont
      { result = [ val[0], *val[2] ].
            reduce { |tree, node| node[3][2] = tree; node }
      }

  filter_chain_cont:
      filter_call pipe filter_chain_cont
      { result = [ val[0], *val[2] ] }
    | filter_call
      { result = [ val[0] ] }

  filter_call:
      ident function_kwargs
      { ident_pos = val[0][1]
        empty_args_pos = { line:  ident_pos[:line],
                           start: ident_pos[:end] + 1,
                           end:   ident_pos[:end] + 1, }
        result = [ :call, val[0][1], val[0],
                   [ :args, val[1][1] || empty_args_pos, nil, val[1][2] ] ]
      }

---- inner
  def parse(string)
    @stream = Lexer.lex(string)
    do_parse
  end

  def next_token
    tok = @stream.shift
    [ tok[0], tok ] if tok
  end

  TOKEN_NAME_MAP = {
    :comma    => ',',
    :dot      => '.',
    :lblock   => '{%',
    :rblock   => '%}',
    :linterp  => '{{',
    :rinterp  => '}}',
    :lbracket => '[',
    :rbracket => ']',
    :lparen   => '(',
    :rparen   => ')',
    :pipe     => '|',
    :op_not   => '!',
    :op_mul   => '*',
    :op_div   => '/',
    :op_mod   => '%',
    :op_plus  => '+',
    :op_minus => '-',
    :op_eq    => '==',
    :op_neq   => '!=',
    :op_lt    => '<',
    :op_leq   => '<=',
    :op_gt    => '>',
    :op_geq   => '>=',
  }

  def on_error(error_token_id, error_token, value_stack)
    type, (pos, value) = error_token
    type = TOKEN_NAME_MAP[type] || type
    raise Liquor::SyntaxError.new("unexpected token `#{type}'", pos)
  end

  def retag(nodes)
    pos = nodes.map { |node| node[1] }.compact
    first, *, last = pos
    return first if last.nil?

    {
      line:  first[:line],
      start: first[:start],
      end:    last[:end],
    }
  end